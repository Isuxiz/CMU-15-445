# 01 数据库简介&初探关系型数据库

## 什么是数据库?

一种对真实世界的建模, 用以收集和组织一系列相关的数据

## 什么是 DBMS?

数据库+配套的管理工具
利用它可以实现数据库的 定义 创建 查询 插入 删除 权限管理 等

## 什么是关系型数据库

1970 Ted Codd 提出的一种数据库模型
有以下三个愿景:
1. 将数据库存储在简单的数据结构中
2. 使用高级语言来实现我们对数据的处理意图
3. DBMS 负责将 2 中提到的高级语言转换为物理操作

## 数据库的分类

- 关系型 DB, 最多最常见的 DB, 也是本课程重点关注的, SQL 是这种数据库的标配
- NoSQL DB, 可以解释为不使用 SQL 的 DB, 也可以解释为 not only SQL 的 DB
  - K-V DB, 高级的哈希表, 典型如 Redis
  - Graph DB, 数据按照图组织, 典型如 Neo4j
  - Document DB, 典型如 MongoDB
  - Column-family DB, 列簇数据库, 按照列的集合组织存储
- 专门存数组或矩阵的 DB, 作为机器学习的基础设施
- 其他历史遗留设计或特殊设计的 DB

## 关系模型

- 字段: 一种数据, 有名字和数据类型
  - `NULL` 是在任何字段中都合法(除非人为设置不准)的特殊值, 代表数据缺失
- 关系: 字段的无序集合, 每张表(的表头)就是一种关系, 如果有一个关系是 n-ary 的, 那么它在关系型数据库中应该是一个 n 列的表
- 实体/元组: 一些字段的值的集合, 每张表中的每一条数据(每一行)就是一个实体
  - 实体中的每个值一般是原子化的, 即不能继续分割的
- 主键: 关系的一个非空子集, 要求主键可以在此关系中唯一确定一个实体
  - 有些关系型数据库会自动添加主键, 另一些需要自己指定
  - 可以在定义表结构时使用关键字让 DBMS 自动为我们生成主键, 在 SQLServer 中是 `SEQUENCE`, 在 MySQL 中是 `AUTO_INCREMENT`
- 外键: 外键, 表示关系 A 中的字段 a 必须映射到关系 B 中的字段 b, 即关系 A 是依赖关系 B 的
  - 一对一的可以直接在表中使用, 如果出现一对多或者多对多, 可以使用全外键的中间表


## DML

data manipulation language, 数据操作语言

增删改查都属于 DML, 其实就是只动数据(而不动表头什么的)的操作

可以区分为两种:
- 过程式的: 用户告知 DBMS 应该怎么样(具体步骤)找到我要的东西, 关系代数属于此类
- 非过程式的(声明式的): 用户只告诉 DBMS 需求, DBMS 自己决定如何找, SQL 和 关系计算属于此类

## 关系代数

一些运算符, 要求输入的是关系, 个数取决于运算符是几元的, 输出的也是关系

运算符:
- SELECT, $\sigma$, 选择, 需要配合谓词使用
- PROJECTION, $\pi$, 投影, 即从现有的若干表映射出一个新的表, 也要配合谓词
- UNION, $\cup$, 取并集, 即竖着拼, 即 SQL 中的 union 或者 union all, 前者自动去重, 后者保留重复
- INTERSECTION, $\cap$, 取交集
- DIFFERENCE, $-$, 差集, 找到在 A 但不在 B 中的实体们
- PRODUCT, $\cross$, 笛卡尔积, 即 SQL 中的 cross join
- JOIN, $\bowtie$, 将两个关系按照条件拼接出新的关系, 即横着拼, SQL 中的 JOIN
- 其他一些关系代数运算符, 重命名, 赋值, 去重, 聚合, 排序, 除法等等

关系代数仍然定义了数据库如何执行

举个例子, (先查再 JOIN) 和 (先 JOIN 再查) 的结果可能是一样的, 但数据库将严格按照指定的顺序执行动作, 因此性能开销也不一样

所以我们希望有一种手段解耦用户的查询需求和数据库的物理动作, 让数据库自己决定如何执行动作, 提供了优化的机会

这不代表关系代数被淘汰了, 当涉及具体实现, 需要描述执行细节时, 使用关系代数仍然是非常合适的

相当于 SQL 是高层抽象, 关系代数是底层实现

## 查询语言

查询语言就是我们找的东西, 它只指定用户的需求, 不指定数据库的执行动作

SQL(和它的许多方言)是查询语言的事实标准

## 小结

- 数据库很有用, 它无处不在
- 关系代数定义了许多原语(运算符)来处理查询, 但它的缺点是耦合了用户的需求和数据库需要执行的物理动作
- 因此我们提出来查询语言解耦, SQL和它的许多方言是事实标准